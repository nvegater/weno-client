# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

type CheckoutSessionResponse {
  errors: [FieldError!]
  sessionStatus: String
  sessionUrl: String
}

type Customer {
  email: String!
  name: String
  paymentMetadata: PaymentMetadata!
}

type CustomerResponse {
  customer: Customer
  errors: [FieldError!]
}

type DateWithTimes {
  date: DateTime!
  durationInMinutes: Float!
  times: [DateTime!]!
}

type Experience {
  allAttendeesAllSlots: Int
  createdAt: DateTime!
  description: String!
  experienceType: ExperienceType!
  id: Int!
  images: [ExperienceImage!]
  pricePerPersonInDollars: Float!
  reservations: [Reservation!]
  slots: [ExperienceSlot!]!
  title: String!
  updatedAt: DateTime!
  winery: Winery!
  wineryId: Int!
}

type ExperienceImage {
  coverPage: Boolean
  createdAt: DateTime!
  experience: Experience!
  experienceId: Float!
  id: Float!
  imageUrl: String!
  updatedAt: DateTime!
}

type ExperienceImageResponse {
  errors: [FieldError!]
  experienceImages: [ExperienceImageUpload!]!
}

type ExperienceImageUpload {
  coverPage: Boolean!
  imageUrl: String!
}

type ExperienceResponse {
  dateWithTimes: [DateWithTimes!]
  errors: [FieldError!]
  experience: Experience
}

type ExperienceSlot {
  createdAt: DateTime!
  durationInMinutes: Int!
  endDateTime: DateTime!
  experience: Experience!
  experienceId: Float!
  id: Int!
  limitOfAttendees: Int!
  noOfAttendees: Int
  slotType: SlotType!
  startDateTime: DateTime!
  updatedAt: DateTime!
}

type FieldError {
  field: String!
  message: String!
}

type GetPreSignedUrlResponse {
  arrayUrl: [PresignedResponse!]
  errors: [FieldError!]
}

type Mutation {
  createCustomer(createCustomerInputs: CreateCustomerInputs!): CustomerResponse!
  createExperience(
    createExperienceInputs: CreateExperienceInputs!
    createRecurrentDatesInputs: CreateRecurrentDatesInputs!
  ): ExperienceResponse!
  createWinery(
    createWineryInputs: CreateWineryInputs!
    userInputs: UserInputs!
  ): WineryResponse!
  saveExperienceImagesUrls(
    experienceId: Int!
    preSignedUrls: [String!]!
  ): ExperienceImageResponse!
  wineryOnboarding(wineryAlias: String!): OnboardingResponse!
}

type OnboardingResponse {
  accountLinkUrl: String
  errors: [FieldError!]
}

type PaymentMetadata {
  username: String!
}

type PresignedResponse {
  getUrl: String
  putUrl: String
}

type Price {
  currency: String!
  id: String!
  tiers: [Tier!]
  tiersMode: String
  type: String!
  unitAmount: Float
  unitAmountDecimal: String
}

type Product {
  description: String!
  id: String!
  images: [String!]!
  name: String!
  price: [Price!]!
  unit_label: String!
}

type ProductsResponse {
  errors: [FieldError!]
  products: [Product!]
}

type Query {
  allPictures: Int!
  allReservations: Int!
  allWineries: Int!
  experienceWithSlots(experienceId: Float!): ExperienceResponse!
  getCheckoutSessionStatus(sessionId: String!): CheckoutSessionResponse!
  getSubscriptionProducts: ProductsResponse!
  getSubscriptionStatus(customerId: String!): String!
  preSignedUrl(presignedUrlInputs: PresignedUrlInput!): GetPreSignedUrlResponse!
  recurrentDates(
    createRecurrentDatesInputs: CreateRecurrentDatesInputs!
  ): RecurrenceResponse!
  winery(getWineryInputs: GetWineryInputs!): WineryResponse!
}

type RecurrenceResponse {
  dateWithTimes: [DateWithTimes!]
  errors: [FieldError!]
}

type Reservation {
  createdAt: DateTime!
  endDateTime: DateTime!
  experience: Experience!
  experienceId: Int!
  id: Int!
  noOfAttendees: Int!
  orderId: String!
  paymentCreationDateTime: String!
  paymentUpdateDateTime: String!
  pricePerPersonInDollars: Float!
  startDateTime: DateTime!
  status: String!
  title: String!
  updatedAt: DateTime!
  userId: String!
}

type Tier {
  flat_amount: Float
  flat_amount_decimal: String
  unit_amount: Float
  unit_amount_decimal: String
  up_to: Float
}

type Winery {
  accountId: String
  amenities: [Amenity!]
  architecturalReferences: Boolean
  contactEmail: String
  contactName: String
  contactPhoneNumber: String
  covidLabel: Boolean
  createdAt: DateTime!
  creatorEmail: String!
  creatorUsername: String!
  description: String!
  enologoName: String
  experiences: [Experience!]
  foundationYear: Int
  googleMapsUrl: String
  handicappedFriendly: Boolean
  id: Int!
  images: [WineryImage!]
  logo: String
  name: String!
  othersServices: [OtherServices!]
  petFriendly: Boolean
  postalAddress: String
  productRegion: String
  productionType: [ProductionType!]
  stripe_customerId: String
  subscription: String
  supportedLanguages: [ServiceLanguage!]
  updatedAt: DateTime!
  urlAlias: String!
  urlImageCover: String
  valley: Valley!
  verified: Boolean
  wineGrapesProduction: [Grape!]
  wineType: [TypeWine!]
  yearlyWineProduction: Int
  younerFriendly: Boolean
}

type WineryImage {
  coverPage: Boolean
  createdAt: DateTime!
  id: Float!
  imageUrl: String!
  updatedAt: DateTime!
  winery: Winery!
  wineryId: Float!
}

type WineryResponse {
  errors: [FieldError!]
  sessionUrl: String
  winery: Winery
}

"Types of wine production"
enum Amenity {
  ACTIVIDADES_EN_VINEDO
  CATAS_MARIDAJES
  CATAS_PRIVADAS
  CATA_BARRICAS
  CREA_TU_MEZCLA
  DEGUSTACION
  PASEO_CARRETA
  RECORRIDO_BODEGA
  RECORRIDO_VINEDOS
  TALLERES_DIDACTICOS
  TERRAZA
  VISITA_CAVA_BARRICAS
}

"Type of experience"
enum ExperienceType {
  CONCERT
  DEGUSTATION
  WINE_DINNER_PAIRING
}

"A winery can have one o more kind of grape"
enum Grape {
  AGLIANICO
  BARBERA
  BRUNELLO
  CABERNET_FRANC
  CABERNET_SAUVIGNON
  CARIGNAN
  CHARDONNAY
  CHENIN_BLANC
  CINSAUL
  COLOMBARD
  GEWURZTRAMINER
  GRENACHE
  GRENACHE_BLANC
  MALBEC
  MALVASIA_BLANCA
  MALVASIA_TINTA
  MERLOT
  MISION
  MONTEPULCIANO
  MOSCATEL
  MOURVEDRE
  NEBBIOLO
  OTRA
  PALOMINO
  PETITE_VERDOT
  PINOT_BLANC
  PINOT_GRIS
  PINOT_NOIR
  RIESLING
  RUBI_CABERNET
  SANGIOVESE
  SAUVIGNON_BLANC
  SEMILLON
  SINSAULT
  SYRAH
  TEMPRANILLO
  VIOGNIER
  ZINFANDEL
}

"differents kind of services"
enum OtherServices {
  BARRA_DE_ALIMENTOS
  HOSPEDAJE
  RESTAURANTE
}

"Types of wine production"
enum ProductionType {
  COMERCIAL
  ORG_BIO_NAT
  TRAD_ARTESANAL
}

"Languages supported by the Wineries"
enum ServiceLanguage {
  ALEMAN
  ESPANOL
  FRANCES
  INGLES
  ITALIANO
  JAPONES
  MANDARIN
  PORTUGUES
  SENAS_MEXICANAS
}

"Type of slot"
enum SlotType {
  ALL_DAY
  ONE_TIME
  RECURRENT
}

"Types of wine produced by a winery"
enum TypeWine {
  BIODINAMICO
  BLANCO_CON_BARRICA
  BLANCO_JOVEN
  CONMEMORATIVO_EDI_LIMITADA
  COSECHA
  DULCE
  ESPUMOSO
  EXCLUSIVO_VENTA_LOCAL
  GENEROSO_FORTIFICADO
  NARANJA
  NATURAL
  ORGANICO
  ROSADO
  TINTO_CRIANZA_BARRICA
  TINTO_JOVEN
}

"Se pueden cargar imagenes para distintos elementos, usuarios, galerias de vi√±eros etc, etc"
enum UploadType {
  EXPERIENCEALBUM
  USERPROFILEPICTURE
  WINERYALBUM
  WINERYLOGO
}

"A winery is in an unique valley, valleys are not identifiable through addresses"
enum Valley {
  CALAFIA
  ENSENADA
  GRULLA
  GUADALUPE
  OJOS_NEGROS
  SANTO_TOMAS
  SAN_ANT_MINAS
  SAN_QUINTIN
  SAN_VICENTE
}

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar DateTime

input CreateCustomerInputs {
  email: String!
  paymentMetadata: PaymentMetadataInputs!
}

input CreateExperienceInputs {
  description: String!
  limitOfAttendees: Float!
  pricePerPersonInDollars: Float!
  title: String!
  typeOfEvent: ExperienceType!
  wineryId: Float!
}

input CreateRecurrentDatesInputs {
  customDates: [DateTime!]
  durationInMinutes: Float!
  endDate: DateTime!
  exceptionDays: [String!]
  exceptions: [DateTime!]
  slotType: SlotType!
  startDate: DateTime!
}

input CreateWineryInputs {
  amenities: [Amenity!]
  contactEmail: String
  contactPhoneNumber: String
  covidLabel: Boolean!
  description: String!
  foundationYear: Int
  googleMapsUrl: String
  name: String!
  productionType: [ProductionType!]!
  subscription: String!
  supportedLanguages: [ServiceLanguage!]
  urlAlias: String!
  valley: Valley!
  wineType: [TypeWine!]!
  yearlyWineProduction: Int
}

input GetWineryInputs {
  creatorUsername: String
  urlAlias: String
}

input PaymentMetadataInputs {
  username: String!
}

input PresignedUrlInput {
  "opcional"
  creatorUsername: String
  "opcional"
  experienceId: Float
  fileNames: [String!]!
  uploadType: UploadType!
  "opcional"
  wineryId: Float
}

input UserInputs {
  cancelUrl: String!
  email: String!
  successUrl: String!
  username: String!
}
